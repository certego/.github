name: Reusable python tests workflow
on:
  workflow_call:
    inputs:
      python_versions:
        description: Python versions to use
        type: string
        required: true
      working_directory:
        description: Directory that must be run against the linters
        type: string
        required: true
      requirements_path:
        description: Path to the requirements.txt file
        type: string
        required: true
      packages_path:
        description: Path to the packages.txt file
        type: string
        required: false


      custom_command:
        description: String of custom command to run
        type: string
        required: false
      django_settings_module:
        description: Path to the django settings file
        type: string
        required: false

      check_migrations:
        description: Check if migrations are valid. Requis django_settings_module to be set.
        type: boolean
        required: false
        default: false
      check_requirements_licenses:
        description: Check if requirements have a valid license. Requis django_settings_module to be set.
        type: boolean
        required: false
        default: true

      use_postgres:
        description: Use postgres service
        default: false
        type: boolean
        required: false
      use_elastic_search:
        description: Use elastic_search service
        default: false
        type: boolean
        required: false
      use_memcached:
        description: Use memcached service
        default: false
        type: boolean
        required: false
      use_redis:
        description: Use redis service
        default: false
        type: boolean
        required: false
      use_rabbitmq:
        description: Use rabbitmq service
        default: false
        type: boolean
        required: false
      use_mongo:
        description: Use mongo service
        default: false
        type: boolean
        required: false
      use_celery:
        description: Create a celery worker
        default: false
        type: boolean
        required: false

      use_unittest:
        description: Use unittest suite
        default: false
        type: boolean
        required: false
      use_pytest:
        description: Use pytest suite
        default: false
        type: boolean
        required: false

      use_coverage:
        description: Use coverage.py. Require pytest or  unittest to be set.
        default: false
        type: boolean
        required: false
      coverage_config_path:
        description: Path to the coverage.py config file
        type: string
        required: false
        default: .coveragerc
      upload_coverage:
        description: Upload coverage.py report to github
        default: false
        type: boolean
        required: false

      postgres_db:
        description: Postgres service db. Requires use_postgres to be true
        type: string
        required: false
        default: db
      postgres_user:
        description: Postgres service user. Requires use_postgres to be true
        type: string
        required: false
        default: user
      postgres_password:
        description: Postgres service password. Requires use_postgres to be true
        type: string
        required: false
        default: password

      celery_app:
        description: Celery app name. Requires use_celery to be true
        type: string
        required: false

      celery_queues:
        description: Celery queues separated by ,. Requires use_celery to be true
        type: string
        required: false
        default: default

      env:
        description: Environment variables to set
        type: string
        required: false
        default: >-
          {}

jobs:
    tests:
        name: Run python tests
        runs-on: ubuntu-latest
        timeout-minutes: 20
        strategy:
          matrix:
            python_version: ${{ fromJson(inputs.python_versions) }}
        env: ${{ fromJson(inputs.env) }}
        steps:
            - uses: actions/checkout@v3

            - name: Export apt requirements
              id: export-apt-requirements
              if: inputs.packages_path
              run: |
                echo ::set-output name=apt-packages::$( cat ${{ inputs.packages_path }} )

            - name: Cache apt packages
              id: cache-apt-packages
              if: inputs.packages_path
              uses: awalsh128/cache-apt-pkgs-action@v1
              with:
                packages: ${{ steps.export-apt-requirements.outputs.apt-packages }}

            - name: Set up Python
              uses: actions/setup-python@v4
              with:
                python-version: ${{ matrix.python_version }}



            - name: Print wrong licenses
              if: steps.license_check_report.outcome == 'failure'
              run: |
                  echo "License check failed"
                  echo "===================="
                  echo "${{ steps.license_check_report.outputs.report }}"
                  echo "===================="
                  exit 1

            - name: Create requirements-dev.txt
              run: |
                echo > requirements-dev.txt
                if [[ ${{ inputs.use_pytest }} != 'false' ]]; then
                  echo "pytest>=7.0.0" >> requirements-dev.txt
                  if [[ -n ${{ inputs.django_settings_module }} ]]; then
                    echo "pytest-django>=4.5.2" >> requirements-dev.txt
                  fi
                fi
                if [[ ${{ inputs.use_coverage }} != 'false' ]]; then
                  echo "coverage>=6.4.1" >> requirements-dev.txt
                  if [[ ${{ inputs.use_pytest }} != 'false' ]]; then
                    echo "pytest-cov>=3.0.0" >> requirements-dev.txt
                  fi
                fi
              shell: bash

            - uses: syphar/restore-virtualenv@v1
              id: cache-virtualenv
              with:
                requirement_files: |
                  ${{ inputs.requirements_path }}
                  requirements-dev.txt

            - uses: syphar/restore-pip-download-cache@v1
              if: steps.cache-virtualenv.outputs.cache-hit != 'true'

            - run: |
                pip install -r ${{ inputs.requirements_path }}
                pip install -r requirements-dev.txt
              if: steps.cache-virtualenv.outputs.cache-hit != 'true'

            - name: Check requirements licenses
              if: inputs.check_requirements_licenses && steps.cache-virtualenv.outputs.cache-hit != 'true'
              id: license_check_report
              continue-on-error: true
              uses: pilosus/action-pip-license-checker@v0.6.2
              with:
                requirements: ${{ inputs.requirements_path }}
                exclude: uWSGI.*|lunardate.*|.*QuokkaClient.*
                table-headers: true
                fail: 'StrongCopyleft,NetworkCopyleft,Error'
                fails-only: true

            - name: Inject django settings module to environ
              if: inputs.django_settings_module
              run: |
                echo "DJANGO_SETTINGS_MODULE=${{ inputs.django_settings_module }}" >> $GITHUB_ENV

            - name: Create mongo docker-compose file
              if: inputs.use_mongo
              run: |
                echo "version: '3.7'" > mongo.yml
                echo "services:" >> mongo.yml
                echo "  mongo:" >> mongo.yml
                echo "    image: library/mongo:4.4" >> mongo.yml
                echo "    container_name: mongo" >> mongo.yml
                echo "    ports:" >> mongo.yml
                echo "      - 27017:27017" >> mongo.yml
                echo "    volumes:" >> mongo.yml
                echo "      - mongo:/data/db" >> mongo.yml
                echo "volumes:" >> mongo.yml
                echo "  mongo:" >> mongo.yml
              shell:
                bash

            - name: Create postgres docker-compose file
              if: inputs.use_postgres
              run: |
                echo "version: '3.7'" > postgres.yml
                echo "services:" >> postgres.yml
                echo "  postgres:" >> postgres.yml
                echo "    image: library/postgres:10.14-alpine" >> postgres.yml
                echo "    container_name: postgres" >> postgres.yml
                echo "    environment:" >> postgres.yml
                echo "      POSTGRES_DB: ${{ inputs.postgres_db }}" >> postgres.yml
                echo "      POSTGRES_USER: ${{ inputs.postgres_user }}" >> postgres.yml
                echo "      POSTGRES_PASSWORD: ${{ inputs.postgres_password }}" >> postgres.yml
                echo "    ports:" >> postgres.yml
                echo "      - 5432:5432" >> postgres.yml
                echo "    healthcheck:" >> postgres.yml
                echo "      test: pg_isready" >> postgres.yml
                echo "      interval: 10s" >> postgres.yml
                echo "      timeout: 5s" >> postgres.yml
                echo "      retries: 5" >> postgres.yml
              shell:
                bash

            - name: Create elasticsearch docker-compose file
              if: inputs.use_elastic_search
              run: |
                echo "version: '3.7'" > elastic_search.yml
                echo "services:" >> elastic_search.yml
                echo "  elastic_search:" >> elastic_search.yml
                echo "    image: elasticsearch:7.10.1" >> elastic_search.yml
                echo "    container_name: elastic_search" >> elastic_search.yml
                echo "    environment:" >> elastic_search.yml
                echo "      ES_JAVA_OPTS: -Xms1g -Xmx1g" >> elastic_search.yml
                echo "      discovery.type: single-node" >> elastic_search.yml
                echo "    ports:" >> elastic_search.yml
                echo "      - 59200:9200" >> elastic_search.yml
                echo "    healthcheck:" >> elastic_search.yml
                echo "      test: curl -X GET 'localhost:9200/_cluster/health?wait_for_status=yellow&timeout=180s&pretty'" >> elastic_search.yml
                echo "      interval: 10s" >> elastic_search.yml
                echo "      timeout: 180s" >> elastic_search.yml
                echo "      retries: 5" >> elastic_search.yml
              shell:
                bash

            - name: Create memcached docker-compose file
              if: inputs.use_memcached
              run: |
                echo "version: '3.7'" > memcached.yml
                echo "services:" >> memcached.yml
                echo "  memcached:" >> memcached.yml
                echo "    container_name: memcached" >> memcached.yml
                echo "    image: memcached:1.6.9-alpine" >> memcached.yml
                echo "    ports:" >> memcached.yml
                echo "      - 11211:11211" >> memcached.yml
              shell:
                bash

            - name: Create redis docker-compose file
              if: inputs.use_redis
              run: |
                echo "version: '3.7'" > redis.yml
                echo "services:" >> redis.yml
                echo "  redis:" >> redis.yml
                echo "    container_name: redis" >> redis.yml
                echo "    image: library/redis:5.0.9-alpine" >> redis.yml
                echo "    ports:" >> redis.yml
                echo "      - 6379:6379" >> redis.yml
              shell:
                bash

            - name: Create rabbitmq docker-compose file
              if: inputs.use_rabbitmq
              run: |
                echo "version: '3.7'" > rabbitmq.yml
                echo "services:" >> rabbitmq.yml
                echo "  rabbitmq:" >> rabbitmq.yml
                echo "    container_name: rabbitmq" >> rabbitmq.yml
                echo "    image: library/rabbitmq:3.9-management-alpine" >> rabbitmq.yml
                echo "    ports:" >> rabbitmq.yml
                echo "      - 15672:15672" >> rabbitmq.yml
                echo "      - 5672:5672" >> rabbitmq.yml
              shell:
                bash

            - name: Execute docker-compose up
              if: inputs.use_postgres || inputs.use_elastic_search || inputs.use_memcached ||  inputs.use_redis || inputs.use_rabbitmq || inputs.use_mongo
              run: |
                CLI=docker-compose
                if [[ ${{ inputs.use_postgres }} != 'false' ]]; then
                  CLI="${CLI} -f postgres.yml"
                fi
                if [[ ${{ inputs.use_elastic_search }} != 'false' ]]; then
                  CLI="${CLI} -f elastic_search.yml"
                fi
                if [[ ${{ inputs.use_memcached }} != 'false' ]]; then
                  CLI="${CLI} -f memcached.yml"
                fi
                if [[ ${{ inputs.use_redis }} != 'false' ]]; then
                  CLI="${CLI} -f redis.yml"
                fi
                if [[ ${{ inputs.use_rabbitmq }} != 'false' ]]; then
                  CLI="${CLI} -f rabbitmq.yml"
                fi
                if [[ ${{ inputs.use_mongo }} != 'false' ]]; then
                  CLI="${CLI} -f mongo.yml"
                fi

                # add other containers here
                echo "Running: ${CLI} up -d"
                $CLI up -d
                $CLI ps
              shell:
                bash

            - name: Start celery worker
              if: inputs.use_celery
              run: |
                celery -A ${{ inputs.celery_app }} worker -E -c 1 -n worker -Q ${{ inputs.celery_queues }} --detach 
              working-directory: ${{ inputs.working_directory }}

            - name: Custom command
              if: inputs.custom_command
              run: |
                COMMAND=${{ inputs.custom_command }}
                echo "Running command: $COMMAND"
                $COMMAND
              working-directory: ${{ inputs.working_directory }}
              shell: bash

            - name: Check migrations
              if : inputs.check_migrations && inputs.django_settings_module
              run: |
                django-admin makemigrations --dry-run >/dev/null
              working-directory: ${{ inputs.working_directory }}
              env:
                PYTHONPATH: ${{ github.workspace }}/${{ inputs.working_directory }}:$PYTHONPATH

            - name: Run unittest
              if: inputs.use_unittest
              run: |
                CMD="python"
                if [[ '${{ inputs.use_coverage }}' != 'false' ]]; then
                    CMD="coverage run --rcfile=${{ inputs.coverage_config_path }}"
                    if [[ -n '${{ inputs.django_settings_module }}' ]]; then
                      CMD="${CMD} -a manage.py test"
                    else
                      CMD="${CMD} -m unittest discover"
                    fi
                else
                  CMD="python -m unittest discover"
                fi
                CMD="${CMD} --failfast"
                echo "Running command: ${CMD}"
                $CMD
              working-directory: ${{ inputs.working_directory }}
              env:
                PYTHONPATH: ${{ github.workspace }}/${{ inputs.working_directory }}:$PYTHONPATH

            - name: Run pytest
              if: inputs.use_pytest
              run: |
                if [[ '${{ inputs.use_coverage }}' != 'false' ]]; then
                  CMD="py.test -l --color=yes --cov --no-cov-on-fail --durations=15 --cov-config=${{ inputs.coverage_config_path }}"
                else
                  CMD="python -m pytest"
                fi
                CMD="${CMD} --exitfirst"
                echo "Running command: ${CMD}"
                $CMD
              working-directory: ${{ inputs.working_directory }}
              env:
                PYTHONPATH: ${{ github.workspace }}/${{ inputs.working_directory }}:$PYTHONPATH

            - name: Create coverage output
              if: inputs.use_coverage && inputs.upload_coverage
              id: coverage-output
              run: |
                echo ::set-output name=coverage_content::$(coverage report -m | awk '{printf "%s<br />", $0}' )
              working-directory: ${{ inputs.working_directory }}
              env:
                PYTHONPATH: ${{ github.workspace }}/${{ inputs.working_directory }}:$PYTHONPATH

            - name: Find Comment
              if: inputs.use_coverage && inputs.upload_coverage
              uses: peter-evans/find-comment@v2
              id: fc
              with:
                issue-number: ${{ github.event.pull_request.number }}
                comment-author: 'github-actions[bot]'
                body-includes: Coverage.py report
                direction: first

            - name: Create or update coverage to PR comment
              if: inputs.use_coverage && inputs.upload_coverage
              uses: peter-evans/create-or-update-comment@v2
              with:
                comment-id: ${{ steps.fc.outputs.comment-id }}
                issue-number: ${{ github.event.pull_request.number }}
                body: |
                  Coverage.py report:
                  ${{ steps.coverage-output.outputs.coverage_content }}
                edit-mode: replace